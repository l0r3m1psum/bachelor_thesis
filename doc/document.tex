\documentclass[draft]{article}

\usepackage[T1]{fontenc} % for italian babel warnings
\usepackage[italian]{babel}
\usepackage{hyperref} %this should always be the last package

% Abbreviazioni
\newcommand{\mytitle}{Specifica dei requisiti per la tesi}
\newcommand{\eng}[1]{\foreignlanguage{english}{#1}} %TODO: add to all english words
\let\oldmarginpar\marginpar
\renewcommand{\marginpar}[1]{\oldmarginpar{\raggedright #1}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\psql}{\texttt{psql(1)}}
\newcommand{\file}{\textit{file}}
\newcommand{\e}{\epsilon}

\newtheorem{requirement}{Requisito}

\hypersetup{
	pdfauthor={Diego Bellani},
	pdftitle={\mytitle},
	pdfsubject={Specifica dei requisiti},
	pdfkeywords={requisiti,tesi},
	pdfproducer={LaTeX},
	pdfcreator={pdfLaTeX},
	pdfborder={0 0 0},
	pageanchor=false
}

\title{\mytitle}
\date{2021}
\author{Diego Bellani\thanks{Studente}\and Enrico Tronci\thanks{Professore}}

\begin{document}

\begin{titlepage}
	\maketitle

	\begin{abstract}
	Questo documento \marginpar{Da espandere.} contiene le specifiche dei
	requisiti per la tesi sulla simulazione \eng{multi-core} di incendi.
	\end{abstract}

	\tableofcontents
	\listoffigures
	\listoftables
\end{titlepage}

\section{Introduzione}

Questa tesi fa parte di un progetto per fornire ai vigili del fuoco uno
strumento per prevedere l'espansione di un incendio in un'area forestale. Questo
saraà fatto utilizzando dei sensori sul campo e dei satelliti per raccogliere le
informazioni. Queste ultime saranno utilizzate da un modello matematico, che
verrà realizzato da un simulatore. In fine i vigili del fuoco lo utilizzeranno
tramite un'interfaccia web.

\section{Ambito della Tesi}

La tesi si occuperà esclusivamente dell'implementazione del modello matematico
fornitoci da Tor Vergata. Durante il documento saranno elencati tutti i suoi
requisiti. Identifichiamo il primo.

\begin{requirement}
La simulazione deve avvenire \eng{faster-then-real-time} per poter effetuare
delle previsioni.
\end{requirement}

\section{Dati a disposizione}

Il simulatore avrà a disposizioni dati geografici e meteo, da satelliti, sulla
zona di interesse per la simulazione. La rona è divisa in rettangoli tutti
uguali e ad ognuno di questi rettangoli avrà dei dati uniformi.

Per identificare i rettangoli sulla mappa essi verranno forniti con coordinate
LAEA\footnote{proiezione Lambert azimuthal Equal-Area} Europe \cite{laeae} con
sistema di riferimento ETRS89\footnote{European Terrestrial Reference System}
\cite{etrs89}.

\paragraph{Dati Geografici}

\marginpar{Più avanti tutti questi dati saranno descritti con più precisione.}

Essi sono: l'altimetria, il tipo di foresta, il livello di urbanizzazione, il
tipo di acqua presente nella zona e la carta natura.

\paragraph{Dati Meteo}

Quelli di interesse sono solo direzione e velocità del vento.

\section{Il Modello}

Il modello matematico che descrive l'evoluzione dell'incendio in un'area
forestale è uno di tipo automa cellulare come quello in figura
\ref{fig:automata}.

\begin{figure}
\centering
\setlength{\unitlength}{0.7cm}
\begin{picture}(6,6)
	\newlength{\piccenter}
	\setlength{\piccenter}{3\unitlength}
	% Grid
	\thicklines
	\multiput(0,0)(2,0){4}{\line(0,1){6}} % columns
	\multiput(0,0)(0,2){4}{\line(1,0){6}} % rows

	% Arrays
	\thinlines
	\put(\piccenter,\piccenter){\vector(1,0){2}}
	\put(\piccenter,\piccenter){\vector(0,1){2}}
	\put(\piccenter,\piccenter){\vector(-1,0){2}}
	\put(\piccenter,\piccenter){\vector(0,-1){2}}
	\put(\piccenter,\piccenter){\vector(1,1){2}}
	\put(\piccenter,\piccenter){\vector(-1,1){2}}
	\put(\piccenter,\piccenter){\vector(1,-1){2}}
	\put(\piccenter,\piccenter){\vector(-1,-1){2}}

	% Black square
	\newlength{\side}
	\setlength{\side}{0.8\unitlength}
	\linethickness{\side}
	\newlength{\ypos}
	\setlength{\ypos}{\piccenter}
	\addtolength{\ypos}{-0.5\side}
	\put(\piccenter,\ypos){\line(0,0){\side}}
\end{picture}
\caption{Automa cellulare}
\label{fig:automata}
\end{figure}

\subsection{Statica}

Il modello ha dei parametri che sono costanti e uguali per tutte le celle,
descritti nella tabella \ref{tab:globals} ed altri, sempre costanti, che possono
cambiare di cella in cella sono descritti nella tabella \ref{tab:params}. Questi
ultimi sono derivati dai dati geografici descritti nella tabella \ref{tab:geo}
con le seguenti corrispondenze matematiche:

\begin{table}
\centering
\begin{tabular}{|c|l|c|}
	\hline
	\textbf{Nome parametro} & \textbf{Descrizione} & \textbf{Unità di Misura}\\
	\hline
	$\tau$ & passo temporale & secondi\\
	$L$ & lunghezza della singola cella & metri\\
	$W$ & ampiezza della singola cella & metri\\
	$L^*$ & lunghezza area monitorata & celle\\
	$W^*$ & ampiezza area monitorata & celle\\
	$\beta$ & consumo combustibile & combustibile/secondo\\
	$\theta$ & probailità propagazione & adimensionale\\
	$k_0$ & ottimizzazione soglia & adimensionale\\
	$k_1$ & ottimizzazione vento & adimensionale\\
	$k_2$ & ottimizzazione pendenza & adimensionale\\
	\hline
\end{tabular}
\caption{Parametri globali del modello.}
\label{tab:globals}
\end{table}

\begin{table}
\centering
\begin{tabular}{|c|l|}
	\hline
	\textbf{Nome parametro} & \textbf{Descrizione}\\
	\hline
	$H_{ij}$ & altezza media della vegetazione\\
	$A_{ij}$ & abitazione media\\
	$W_{ij}$ & presenza di acqua\\
	$\gamma_{ij}$ & quantità di combustibile\\ % non è chiaro come calcolarlo
	$S_{ij}$ & indice di infiammabilità\\
	$P_{ij}$ & altitudine media\\
	$D_{ij}$ & direzione del vento\\
	$F_{ij}$ & velocità del vento\\
	\hline
\end{tabular}
\caption{Parametri delle singole celle.}
\label{tab:params}
\end{table}

\begin{table}
\centering
\begin{tabular}{|c|l|c|}
	\hline
	\textbf{Nome Dato} & \textbf{Descrizione} & \textbf{Intervallo valori}\\
	\hline
	$G_{ij}$ & Foreste & 0,1,2,255\\
	$U_{ij}$ & Urbanizzazione & 0,\ldots,100,255\\
	$W1_{ij}$ & Water1 & 0,\ldots,4,253,255\\
	$W2_{ij}$ & Water2 & 0,1\\
	$P_{ij}$ & Altimetria & 0,\ldots,4380\\
	\hline
\end{tabular}
\caption{Dati geografici per le singole celle.}
\label{tab:geo}
\end{table}

\marginpar{In seguito saranno fatte delle precisazioni su alcune di queste
corrispondenze.}

\begin{eqnarray}
H_{ij} &=& \cases{1 + G_{ij}, &se $0 \leq H_{ij} \leq 2$;\cr
                  0, &se $H_{ij} = 255$.}\\
A_{ij} &=& \cases{U_{ij}/100, &se $0 \leq U_{ij} \leq 100$;\cr
                  0, &se $U_{ij} = 255$.}\\
W_{ij} &=& \cases{0, &se $W1_{ij} = 0$;\cr
                  1, &se $W1_{ij} = 1$;\cr
                  0.75, &se $W1_{ij} = 2$;\cr
                  0.75, &se $W1_{ij} = 3$;\cr
                  0.5, &se $W1_{ij} = 4$;\cr
                  1, &se $W1_{ij} = 253$;\cr
                  1, &se $W1_{ij} = 255$.}\\
S_{ij} &=& H_{ij} \cdot (1-A_{ij}) \cdot (1-W_{ij})\textrm{,}\\
P_{ij} &=& P_{ij}\textrm{.}
\end{eqnarray}

\subsection{Dinamica}

Ora che tutta la parte statica del modello è stata descritta e possiamo passare
alla sua dinamica. Questa è descritta tramite tre funzioni diopendenti descritte
nella tabella \ref{tab:dynamic}.

\begin{table}
\centering
\begin{tabular}{|c|l|}
	\hline
	\textbf{Nome parametro} & \textbf{Descrizione}\\
	\hline
	$B_{ij}(t)$ & combustibile disponibile\\
	$N_{ij}(t)$ & stato (in fiamme o meno)\\
	$p_{ij}(\epsilon_1, \epsilon_2, t)$ & probabilità di trasmissione\\
	\hline
\end{tabular}
\caption{Parametri delle singole celle che variano nel tempo.}
\label{tab:dynamic}
\end{table}

Le funzioni in quest'ultima tabella sono definite come segue

\begin{eqnarray}
p_{ij}(\e_1, \e_2, t) &=& k_0 S_{ij} C(i+\e_1, j+\e_2) d(\e_1, \e_2) f_w f_P\textrm{,}\label{eq:prob}\\
(\e_1, \e_2) &\in& \Gamma = \{\,(x, y) \mid x, y \in \{-1, 0, 1\}\,\}\textrm{,}\\
C(i,j) &=& \sin\left(\pi\frac{B_{ij}}{\gamma_{ij}}\right)\textrm{,}\label{eq:combust}\\
d(\e_1,\e_2) &=& \left(1-\frac{1}{2}|\e_1\e_2|\right)\textrm{,}\label{eq:disom}\\
f_w &=& \exp\left(k_1 F(i+\e_1, j+\e_2)\frac{\begin{array}{l}\e_1\cos(D(i+\e_1,j+\e_2))\\
        \mbox{}+\e_2\sin(D(i+\e_1,j+\e_2))\end{array}}{\sqrt{\e_1^2 + \e_2^2}}\right)\textrm{,}\label{eq:wind}\\
f_P &=& \exp\left(k_2\arctan\left(\frac{P_{ij}-P_{i+\e_1j+\e_2}}{L}\right)\right)\textrm{.}\label{eq:slope}
\end{eqnarray}

\marginpar{Definirla una probabilità è incorretto siccome la funzione è
deterministica.}

Dove la funzione \ref{eq:prob} è la probabilità che un incendio si traspetta da
una cella $(i, j)$ ad un'altra $(i+\e_1, j+\e_2)$. Al suo interno la funzione
\ref{eq:combust} indica lo stato di combusione della cella, la \ref{eq:disom} è
il fattore di disomogeneità, mentre \ref{eq:wind} e \ref{eq:slope} sono il
contributo alla probabilità del vento e della pendenza rispettivamente.

Invece \marginpar{Da riscrivere il paragrafo su $Q$.}

\begin{equation}
Q_{ij}(\e_1, \e_2, t) = \cases{1, &se $p_{ij}(\e_1, \e_2) N_{i+\e_1j+\e_2} > \theta$;\cr
                               0, &altrimenti.}
\end{equation}

Quindi $Q_{ij}(\e_1, \e_2, t) = 1 \iff N_{i+\e_1j+\e_2} = 1 \land
p_{ij}(\e_1, \e_2) > \theta$, in questo caso l'incendio nella cella limitrofa
$(i+\e_1, j+\e_2$ si trasferisce nella cella $(i,j)$. In fine per controllare
tutte le celle limitrofe ad una useremo la seguente funzione

\begin{equation}
V_{ij}(t) = \max\{\,Q_{ij}(\e_1, \e_2, t) \mid (\e_1, \e_2) \in \Gamma\,\}\textrm{,}
\end{equation}

la quale è 1 quando una cella limitrofa a $(i, j)$ porta l'incendio nella cella
stessa.

\marginpar {Ovviamente l'\eng{input} esogeno può cambiare nel tempo.}

In fine sia $u_{ij}$ l'\eng{input} esogeno che definisce o lo stato di quete o di
incendio con i valori 0 e 1 rispettivamente, che all'atto pratico è ottenuta
attraverso dati sul campo. La dinamica del sistema è la seguente:

\begin{eqnarray}
N_{ij}(0) &=& u_{ij}(0)\textrm{,}\\
B_{ij}(0) &=& \gamma_{ij}\textrm{,}\\
N_{ij}(t+1) &=& \cases{\max(V_{ij}(t), u_{ij}(t)), &se $B_{ij}(t) > 0$;\cr
                       0, &altrimenti.}\\
B_{ij}(t+1) &=& \cases{\max(0, B_{ij}(t)-\beta\tau), &se $N_{ij}(t) > 0$;\cr
                       B_{ij}(t), &altrimenti.}
\end{eqnarray}

% TODO: descrivere il comportamento del vento (gaussiano)

\section{Il Simulatore}

\marginpar{Questa sezione è da riorganizzare e riscrivere.}

Il programma dovrà simulare l'evoluzione dell'incendio dati il modello e i dati
descritti sopra. Data la grandezza dell'area descritta\footnote{Probabilmente
questo è il termine sbagliato.} da \cite{laeae}, il programma effetuerà la
simulaizone solo su una piccola parte di quest'ultima.

\begin{requirement}\label{thm:subrect}
Il simulatore deve poter simulare su dei sotto rettangoli di \cite{laeae} a
scelta.
\end{requirement}

Nel modello non è specificata nessuna condizione di terminazione e per quanto
sia possibile far continuare la simulazione per un tempo indeterminato è più
comodo specificare un \emph{orizonte di simulazione}.

\begin{requirement}\label{thm:horizon}
La simulazione andrà avanti fino ad un determinato orizonte $h$.
\end{requirement}

Inoltre avrebbe senso e farebbe comodo agli utenti poter vedere lo stato della
simulazione anche prima che questa termini, per poter creare cose come ad
esempio animazioni.

\begin{requirement}\label{thm:snapshot}
Il simulatore deve esporre il suo stato interno ogni $s$ step, questo numero è
detto frequenza di \eng{snapshot}.
\end{requirement}

Alcuni dati, come la direzione e la forza del vento, potrebbero drasticamente
cambiare ad un certo punto della simulazione. Essendo questa
\eng{faster-then-real-time} potrebbe essere necessario riprendere la
simulzione da un certo punto nel passato\footnote{Di cui convenientemente
teniamo degli \eng{snapshot}, come descritto nel requisito \ref{thm:snapshot}.}.
Lo stesso discorso vale per la comparsa di nuovi focolai in punti non
previsti\footnote{Questa è un eventualità probabile nel caso di incendi dolosi.}.

\marginpar{Ritengo sia meglio fare così rispetto al monitorare per la presenza
di nuovi \eng{file} dirante la simulazione, sia per semplicità che per
correttezza siccome la simulaizone è \eng{faster-then-real-time}.}

\begin{requirement}
Il simulatore deve poter essere inizializzato con uno stato iniziale arbitrario.
\end{requirement}

\begin{requirement}\label{thm:termination}
Il simulatore deve poter essere fermato in maniera ``gentile''.
\end{requirement}

Il sottorettangolo del requisito \ref{thm:subrect}, sarà espresso come una
coppia di coordinate $p_1$ e $p_2$ che indicheranno rispettivamente l'angolo in
basso a sinistra e l'angolo in alto a destra del rettandolo selezionato.

Per garantire la correttezza dei risultati il simulatore deve poter validare
ciò che riceve in \eng{input} e per fare ciò deve ricevere delle specifiche sul
formato dei dati, come la loro grana (i.e. quanto spazio ricopre ogni singolo
\eng{datapoint}).

\begin{requirement}\label{thm:schema}
Il dati devono essere corredati di una sorta di schema che ne specifici le
caratteristiche.
\end{requirement}

\begin{requirement}
Il simulatore deve validare i dati che riceve basandosi sugli schemi del
requisito \ref{thm:schema}.
\end{requirement}

Per come è scritto il modello se eseguito su un'area rettangolare non specifica
cosa fare sui contorni del rettangolo, ovvero cosa fare quanto intorno ad ogni
cella non ci sono 8 altre celle.

\begin{requirement}\label{thm:boundary}
Il siumulatore deve gestire la simulazione nei contorni dell'area rettangolare.
\end{requirement}

Mentre come descritto dal requisito \ref{thm:schema} i dati hanno delle grane,
non necessariamente uguali tra loro, anche il simulatore ne ha una sua interna
sia per permettere una maggiore precisione nei risultati che per permettere dati
con granularità diversa.

\begin{requirement}\label{thm:grain}
Il simulatore deve avere una sua grana interna, necessariamente minore uguale a
quella dei dati ricevuti in \eng{input}.
\end{requirement}

\subsection{Dettagli di implementazione}

Il simulatore girera su un \eng{kernel} Linux, e sarà, probabilmente, invocato
da un servizio \eng{web}. Tutti i dati necessari per la simulazione saranno
letti da \eng{file} CSV.

\begin{requirement}
Il simulatore deve poter leggere i \eng{file} CSV.
\end{requirement}

La terminazione ``gentile'', descritta nel requisito \ref{thm:termination} sara
effetuata alla ricezione del segnale \texttt{SIGUSR1} dal processo.

\begin{requirement}
Il programma deve poter ricevere e gestire segnali.
\end{requirement}

Il requisito \ref{thm:boundary} sarà gestito semplicemente ignorando il contorno
dell'area rettangolare, come in figura \ref{fig:boundary}, questo perché l'area
selezionata dovrebbe essere comunque abbastanza grande da non influire sul
risultato finale e per rimanere il più fedeli al modello possibile, senza
contare la semplicità di implementazione.

% TODO: 90 deg to the right to avoid the ugly hack
\begin{figure}
\centering
\setlength{\unitlength}{0.7cm}
\begin{picture}(6,6)
	% Grid
	\thicklines
	\newlength{\cellside}\setlength{\cellside}{1.5\unitlength}
	\newcommand{\cellbars}{4}
	\multiput(0,0)(\cellside,0){\cellbars}{\line(0,1){5}} % columns
	\multiput(0,0)(0,\cellside){\cellbars}{\line(1,0){5}} % rows

	\newlength{\dotslength}\settowidth{\dotslength}{\dots}
	\newlength{\dotsdist}\setlength{\dotsdist}{6\unitlength minus 0.5\cellside}
	\addtolength{\dotsdist}{-\dotslength}
	\put(\dotsdist, 0.5\cellside){\dots}
	\put(0.5\cellside, \dotsdist){\vdots}
	\put(\dotsdist, \dotsdist){$\cdot^{\cdot^\cdot}$} % Ugly hack

	\newsavebox{\cross}
	\savebox{\cross}(0.7,0.7)[bl]{
		\put(0,0){\line(1,1){1}}
		\put(1,0){\line(-1,1){1}}
	}
	\multiput(0.3,0.3)(\cellside,0){3}{\usebox{\cross}}
	\multiput(0.3,0.3)(0,\cellside){3}{\usebox{\cross}}
\end{picture}
\caption{Contorno ignorato.}
\label{fig:boundary}
\end{figure}

Oltre ai parametri nella tabella \ref{tab:globals} il simulatore ha anche
bisogno di alcuni parametri agiuntivi, descritti rispettivamente nei requisiti
\ref{thm:horizon}, \ref{thm:snapshot}, \ref{thm:subrect} e \ref{thm:grain},
riassunti nella tabella \ref{tab:config}.

\begin{table}
\centering
\begin{tabular}{|c|l|}
	\hline
	\textbf{Nome parametro} & \textbf{Descrizione}\\
	\hline
	$h$ & orizonte di simulazione\\
	$s$ & frequanza \eng{snapshot}\\
	$p_1$ & primo punto rettangolo\\
	$p_2$ & secondo punto rettangolo\\
	$g$ & grana simulatore\\
	\hline
\end{tabular}
\caption{Parametri di configurazione addizionali del simulatore.}
\label{tab:config}
\end{table}

% TODO: definire bene il formato dei file di output, perché da essi dipende
% la possibilità di poter far cominciare la similazione con in input uno stato
% raggiunto in precedenza.

\vspace{0.5cm}{\huge -- Da qua in poi è tutto da riscrivere --}

\noindent\hrulefill % ----------------------------------------------------------

% $\alpha$ costante di conversione del compustibile (nostra pezza in attesa di Tor Vergata)

\subsubsection{Formato dei CSV}

\marginpar{Unità di misura dei dati? Tipo dei dati (int o float)?}

I CSV emessi dalla base di dati conterranno in ogni riga i dati che si
riferiscono ad una singola cella. I \file\ che ne indicano la grana avranno
invece una struttura come quella della tabella \ref{tab:grain}, dove $x_n$ e
$y_n$ rappresentano le coordinate degli angoli dell'area di interesse mentre
\eng{length} e \eng{width} rappresentano, rispettivamente, la lunghezza e l
larghezza di ogni singola cella.

\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|c|}
	\hline
	$x_1$ & $y_1$ & $x_2$ & $y_2$ & \textbf{\eng{length}} & \textbf{\eng{width}}\\
	\hline
	450070 & 12980 & 670010 & 13300 & 1 & 1\\
	\hline
\end{tabular}
\caption{Esempio \eng{file} grana.}
\label{tab:grain}
\end{table}

Quelli emessi dal simulatore invece avranno una struttura come quella della
tabella \ref{tab:output}.

\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|}
	\hline
	$n_{11}$ & $b_{11}$ & \dots & $n_{1i}$ & $b_{1i}$\\
	\vdots & \vdots & $\ddots$ & \vdots & \vdots\\
	$n_{j1}$ & $b_{j1}$ & \dots & $n_{ji}$ & $b_{ji}$\\
	\hline
\end{tabular}
\caption{Esempio \eng{output} simulatore.}
\label{tab:output}
\end{table}

Dove $n$ è lo stato della cella, in fiamme o meno, e $b$ è la sua quantità di
combustibile ancora a disposizione.

\section{Isolamento del simulatore dall'esterno}

Per isolare il simulatore dall'esterno ed integrare tutti i dati useremo una
base di dati, in particolare PostgreSQL 13 \cite{psql}, che ci permetterà di
gestire i vari dati di cui la simulazione ha bisogno in maniera uniforme.

\subsection{Creazione dello schema per la base di dati}

Questo programma deve creare la base di dati, tabelle con vincoli, \eng{view}
sui dati e vincoli per mantenerne la consistenza. Questo può essere realizzato
tramite un file SQL che verrà interpretato da \psql.

\subsection{Importazione dei dati}
\label{sec:import}

Questo programma deve importare dati nella base di dati, principalmente dei CSV,
un esempio di come si potrebbe fare da \psql\ è in figura \ref{fig:import}.

\begin{figure}
\centering\verb+\copy <table> from 'data.csv' with format csv;+
\caption{Importazione dei dati nella base.}
\label{fig:import}
\end{figure}

\subsection{Esportazione dei dati}

In maniera molto simile all'importazione (sezione \ref{sec:import}) i dati
possono essere esportati grazie a \psql, come in figura \ref{fig:export}.

\begin{figure}
\centering\verb+\copy <table> to 'export.csv' with format csv;+
\caption{Esportazione dei dati dalla base.}
\label{fig:export}
\end{figure}

\bibliographystyle{plain}
\bibliography{document}

\iffalse % Old stuff for updating the data mid simulation
I dati saranno quindi presi in \eng{input} da tre \file\ CSV: uno per i dati
geografici, uno per quelli meteorologici e uno per lo stato iniziale
dell'incendio. Ognuno di questi file sarà corredato da un'altro CSV che ne
conterrà le informazioni sulla ``grana''.

Per permettere l'aggiornamento di questi dati durante la simulazione il
simulatore monitorerà la presenza di \file\ con nomi come \texttt{land.csv},
\texttt{meteo.csv} e \texttt{fire.csv}. Nel caso in cui uno di questi file sia
presente, dopo l'inizio della simulazione il simulatore provvederà a leggerli,
aggiornare il suo stato interno e cambiargli nome\footnote{con nomi tipo
\texttt{land\_<timestamp>.csv}} (o eliminarli) per evitare di rileggerli in
futuro.

Un implementazione ingenua della scrittura di questi file per l'aggiornamento
dei dati potrebbe generare una \eng{race-condition}, ovvero la lettura di
incompletidati, dato che la scrittura in un file non è atomica. Per evirate ciò
una strateggia potrebbe essere quella di scrivere i dati in file con nomi tipo
\texttt{tmpXXX} e una volta finito di scriverli si può usare \texttt{rename(2)},
che è atomica, per dargli il nome giusto. Questo metodo sarà anche usata per la
scrittura dei file.
\fi

\end{document}
